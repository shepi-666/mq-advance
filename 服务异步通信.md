# 0 MQ常见的问题

![](https://shepi-1308499968.cos.ap-chengdu.myqcloud.com/img/MQ常见的一些问题.png)



# 1 消息的可靠性

消息在传递的过程中有可能出现消息的丢失

* 发送时丢失
  * 生产者发送的消息没有到交换机
  * 消息到达交换机之后没有到达队列
* MQ宕机
* 消费者接收到消息但是没有消费就宕机了

## 1.1 生产者消息确认

RabbitMQ提供了`publisher confirm`机制来避免消息传输过程中的丢失。消息达到MQ队列之后会返回一个结果给发送者，表示消息是否处理成功

* `publisher confirm`：发送者确认
  * 消息成功投递到交换机， 返回`ack`
  * 消息未被投递到交换机，返回`nack`
* `publisher-return`：发送者回执
  * 消息投递到交换机了，但是没有路由到队列，返回`ack`，以及路由失败原因

![](https://shepi-1308499968.cos.ap-chengdu.myqcloud.com/img/生产者确认机制.png)

> 确认机制发送消息的时候，必须有一个全局唯一的id给每一个消息，避免`ack`冲突



### 1.1.1 springAMQP生产者确认

1 在生产者微服务中的配置文件中添加配置

* `pulisher-confirm-type`：开启`publisher-confirm`，支持两种类型
  * `simple`：同步等待`confirm`结果，直到超时
  * `correlated`：异步回调，定义`confirmCallback`，MQ返回结果的时候会回调这个`ConfirmCallback`
* `publishe-returns`：开启`publish-return`功能，同样是基于`callback`机制，不多时定义`returnCallback`
* `template.mandatory`：定义消息路由失败时候的策略，`true`：调用`ReturnCallback`

2 每一个RabbitTemplate只能配置一个ReturnCallback，需要在项目启动过程配置

3 发送消息，指定消息的Id，消息`ConfirmCallback`



## 1.2 消息持久化

MQ默认是内存存储消息，开启持久化功能可以确保缓存在MQ中的消息不会丢失。

> 在spring中，默认方式创建队列，交换机以及消息都是持久化的。



## 1.3 消费者消息确认

支持消费者确认机制：消费者在处理消息之后可以向MQ发送ack回执，MQ收到ack回执之后才会删除该消息。而springAMQP允许配置三种确认模式：

* `manual`：手动ack，需要在业务代码结束之后，调用api发送 ack
* `auto`：自动ack，spring检测listener代码是否出现异常，没有出现异常则返回ack
* `none`：关闭ack，假定消费者获取消息之后一定会处理成功



## 1.4 消费失败重试机制

当消费者不断出现异常之后，消息会不断热queue到队列之中，在重新发送给消费者，再次requeue，无限循环，导致mq的消息处理飙升，带来不必要的压力

我们可以利用spring的retry之计，在消 费者出现异常的时候利用本地重试，而不是无限制的requeue到mq队列。

### 1.4.1 消费者失败之后的处理策略

重试次数耗尽之后，如果消息依然失败，则需要有`MessageRecoverer`接口来处理，他包含三种不同的实现：

* `RejectAndDontRequeueRecoverer`：重试耗尽之后，直接丢弃，默认方式
* `ImmediateRequeueMessageRecoverer`：返回`nack`，消息重新入队
* `RepublishMessageRecoverer`：重试耗尽之后，将失败的消息投递到指定的交换机







# 2 死信交换机

## 2.1 初始死信交换机

当一个队列中的消息满足下列情况之一的时候，就会称为死信（dead letter）：

* 当消息是一个过期消息的时候，超时无人消费
* 需要投递的队列消息堆积慢了，最早的消息就可能成为死信
* 消费者使用`basic.reject`或者`basic.nack`声明消费失败，并且消息的requeue参数设置为`false`

如果一个队列配置了死信交换机，那么队列中的死信就会投递到这个交换机。这个交换机就成为死信交换机。

![](https://shepi-1308499968.cos.ap-chengdu.myqcloud.com/img/死信交换机和republishMessageRecoverer的区别.png)



> 如何给队列绑定死信交换机？
>
> * 给队列设置dead-letter-exchange属性，绑定一个交换机
> * 给队列设置dead-letter-routing-key属性，设置死信交换机和死信队列的Routingkey







## 2.2 TTL

Time To Live，就是消息的存活时间，如果一个队列中的消息TTL结束仍然没有被消费，则会变为死信，TTL超时分为两种情况：

* 消息所在的队列设置了存活时间
* 消息本身设置了存活时间

![](https://shepi-1308499968.cos.ap-chengdu.myqcloud.com/img/TTL.png)

> 当两个都设置了存活时间的时候，以较短的存活时间为准。

## 2.3 延迟队列

利用TTL结合死信交换机，我们实现了消息延迟收到消息的效果。这种消息模式就被称为延迟队列模式。

延迟队列的使用场景：

* 延迟发送短信
* 用户下单，超过15分钟未支付，则自动取消
* 预约工作会议，20分钟之后通知所有的与会人员





# 3 惰性队列

## 3.1 消息堆积问题

当生产者发送消息的速度超过了消费者的速度，就会导致队列中的消息堆积，直到队列存储信息达到上限，最早接受到的消息就可能称为死信，就会被丢弃，这就是消息堆积问题。

解决消息堆积的三种思路：

* 增加跟多的消费者，提高消费速度
* 在消费者内部开启线程池，加快消息处理的速度
* 扩大队列容积，提高堆积上限



## 3.2 惰性队列

惰性队列的特性如下：

* 接受到消息之后直接存储到磁盘中而非内存
* 消费者需要消费消息的时候才将磁盘中读取并加载到内存
* 支持数百万条的消息存储



惰性队列的缺点：

* 基于磁盘存储，消息的实效比较低
* 性能受限于磁盘的IO

# 4 MQ集群

## 4.1 集群分类

RabbitMQ的集群有两种模式：

* **普通集群**：是一种分布式集群，将队列分散到集群的各个节点，从而提高整个集群的并发能力
* **镜像集群**：是一种主从集群，在普通集群的基础上，添加了主从备份功能，从而提高集群数据的可用性

镜像集群虽然支持主从，但是主从同步并不是强一致的，某些情况下可能有数据丢失的风险，因此RabbitMQ3.8之后提供了新的功能，**仲裁集群**来代替镜像集群，底层采用Raft协议确保主从数据的一致性。



## 4.2 普通集群

普通集群具备下列特征：

* 会在集群的各个节点共享部分数据：交换机，队列元信息，但是不包含队列中的消息
* 当访问某一个节点的时候，如果队列不再该节点，就会从数据所在的节点传递到当前节点并返回
* 一旦队列所在的节点宕机，队列中的消息就会丢失



> cookie：LHXPVLRUJBZSKZODJVUK





## 4.3 镜像集群

镜像集群本质就是主从模式，具备以下的特征：

* 交换机、队列、队列中的消息会在各个mq的镜像节点之间同步备份
* 创建队列的节点被称为该队列的**主节点**，被分到其他节点叫作该队列的**镜像节点**
* 一个队列的主节点可能是两一个队列的镜像节点
* 所有的操作都是在注解点完成的，然后同步给主节点
* 主节点宕机之后，镜像节点会成为新的主

![](https://shepi-1308499968.cos.ap-chengdu.myqcloud.com/img/镜像节点的结构.png)





## 4.4 仲裁队列

仲裁队列具有下列特征：

* 与镜像队列一样，都是主从模式，支持数据同步
* 使用非常简单，没有复杂的配置
* 主从同步基于`Raft`协议，强一致